import cv2
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from typing import List, Tuple
import math
import csv


def edge_detect(img: str,
                t1: int = 400,
                t2: int = 500) -> List[Tuple]:
    """
    Finds the pixels that represents the edges in an image,\
    using Canny Edge Detection

    Args:
        img (str): Filename of the image
        t1 (int, optional): First threshold value for edge\
            detection. Defaults to 400.
        t2 (int, optional): Second threshold value for edge\
            detection. Defaults to 500.

    Returns
    -------
        A list of tuples: A list of pixels
    """
    img = cv2.imread(img)

    # get grayscale and blur for better edge detection
    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    img = cv2.GaussianBlur(img, (3, 3), 0)

    # Canny edge detection
    img = cv2.Canny(image=img, threshold1=t1, threshold2=t2)

    # Get list of pixels represnting the edges
    idx = np.nonzero(img)
    return list(zip(idx[0], idx[1]))


def adjacent(p1: Tuple,
             p2: Tuple) -> bool:
    """
    Checks if two points are adjacent to each other

    Args:
        p1 (Tuple): first point
        p2 (Tuple): 2nd point

    Returns
    -------
        bool: If the points are close
    """
    x1, y1 = p1
    x2, y2 = p2
    # if x are the same, and if y differ by one
    if x1 == x2:
        if abs(y1-y2) == 1:
            return True

    # if y are the same, and if x differ by one
    elif y1 == y2:
        if abs(x1-x2) == 1:
            return True

    return False


def dist(p1: Tuple,
         p2: Tuple) -> float:
    """
    Calculates distance between two points.

    Args:
        p1 (Tuple): point 1
        p2 (Tuple): Point 2

    Returns
    -------
        float: Distance
    """
    x1, y1 = p1
    x2, y2 = p2
    dx = x1-x2
    dy = y1-y2

    return math.sqrt(dx*dx + dy*dy)


def generate_waypoints(idx_list: List[Tuple],
                       xleft: float,
                       ybot: float,
                       xright: float,
                       ytop: float,
                       resolution: float,
                       uniform_scale: bool = True) -> (List[float], List[float]):
    """
    Generate a list of waypoints

    Args:
        idx_list (List(Tuple)): A list of points generated by edge detection and np.nonzero.\
                                Represents an image
        xleft (float): Left x-coordinate of the bounding box for the waypoints
        ybot (float): Bottom y-coordinate of the bounding box for the waypoints
        xright (float): Right x-coordinate of the bounding box for the waypoints
        ytop (float): Top y-coordinate of the bounding box for the waypoints
        uniform_scale (bool, optional): Determines if uniform scaling is used to preserve the\
                                        original shape of the image. Defaults to True

    Returns
    -------
        Two lists: A list of x-values and a list of y-values representing the waypoints
    """
    # Rotate and flip the image
    points = [(x, -y) for y, x in idx_list]

    sortedx = []
    sortedy = []
    curr_point = points.pop()
    sortedx.append(curr_point[0])
    sortedy.append(curr_point[1])
    xmin, xmax = curr_point[0], curr_point[0]
    ymin, ymax = curr_point[1], curr_point[1]

    # while list isn't empty, keep searching
    while len(points) > 0:
        temp = None
        close = None
        small_dist = math.inf

        # go through each point and find the next one to connect to
        for point in points:
            # update closest neighbor
            if (dist(point, curr_point) < small_dist):
                close = point
                small_dist = dist(point, curr_point)

            # Check if the next point is one pixel away
            # store it, and exit the loop
            if (adjacent(curr_point, point)):
                temp = point
                break  # exits the upper for loop

        # if there is no next point
        if temp == None:
            temp = close

        # update point, add to array, and remove from list
        curr_point = temp
        sortedx.append(curr_point[0])
        sortedy.append(curr_point[1])
        points.remove(curr_point)

        # update mins and maxs
        xmin = min(xmin, curr_point[0])
        xmax = max(xmax, curr_point[0])
        ymin = min(ymin, curr_point[1])
        ymax = max(ymax, curr_point[1])

    # Calculate scaling values
    xscale = (xright-xleft)/(xmax-xmin)
    yscale = (ytop-ybot)/(ymax-ymin)

    if uniform_scale:
        # Scale to the min value
        scale = min(xscale, yscale)

        # Calculate centers
        xcenter = (xleft+xright)/2
        ycenter = (ytop+ybot)/2

        # Calculate center of original image
        xcenter_img = (xmin+xmax)/2
        ycenter_img = (ymin+ymax)/2

        # Scale and shift using centers to make sure image is centered
        sortedx = [xcenter + (point-xcenter_img)*scale for point in sortedx]
        sortedy = [ycenter + (point-ycenter_img)*scale for point in sortedy]

    else:
        # Non-uniform scaling would force the imagee to fit the whole
        # area, so centering is not needed
        sortedx = [xleft+(point-xmin)*xscale for point in sortedx]
        sortedy = [ybot+(point-ymin)*yscale for point in sortedy]

    # remove unnecessary points based on resolution
    currx = math.inf
    curry = math.inf
    x = []
    y = []

    for i in range(len(sortedx)-1):
        if(dist((currx, curry), (sortedx[i], sortedy[i])) > resolution):
            currx = sortedx[i]
            curry = sortedy[i]
            x.append(currx)
            y.append(curry)

    return (x, y)


idx2_list = edge_detect('cube.png')


xleft = 0.05
xright = 0.95
ybot = 0.3
ytop = 1.3
(arrx, arry) = generate_waypoints(idx2_list,
                                xleft,
                                ybot,
                                xright,
                                ytop,
                                0.01)

# # Plotting
# fig, ax = plt.subplots()
# ax.set_xlim(-50, 50)
# ax.set_ylim(-50, 50)
# line, = ax.plot([], [], marker='o', markersize=1,
#                 color='black', alpha=1.0, linestyle='None')

def generate_csv(x, z):
    filename = "/home/kyle/winterProject/src/uav_trajectories/build/test.csv"
    with open(filename, 'w') as csvfile:
        writer = csv.writer(csvfile)
        for i in range(len(x)):
            t = [x[i], -0.5, z[i]]
            writer.writerow(t)

print(len(arry))
generate_csv(arrx, arry)

# Function to update the plot for each frame of the animation
# def update(frame):
#     if frame < len(arrx):
#         x = arrx[:frame+1]
#         y = arry[:frame+1]
#         line.set_data(x, y)
#         return line,
#     else:
#         return line,


# # Create the animation
# ani = FuncAnimation(fig,
#                     update,
#                     frames=len(arrx)+1,
#                     blit=True,
#                     interval=1)

# plt.show()
